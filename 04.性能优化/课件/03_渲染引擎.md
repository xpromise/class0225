# 浏览器渲染引擎
## 主要模块
* 一个渲染引擎主要包括：HTML解析器，CSS解析器，javascript引擎，布局layout模块，绘图模块
	* HTML解析器：解释HTML文档的解析器，主要作用是将HTML文本解释成DOM树。
	* CSS解析器：级联样式表的解析器，它的作用是为DOM中的各个元素对象计算出样式信息，为布局提供基础设施
	* Javascript引擎：使用Javascript代码可以修改网页的内容，也能修改css的信息，javascript引擎能够解释javascript代码，并通过DOM接口和CSSOM接口来修改网页内容和样式信息，从而改变渲染的结果。
	* 布局（layout）：在DOM创建之后，Webkit需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的内部表示模型
	* 绘图模块（paint）：使用图形库将布局计算后的各个网页的节点绘制成图像结果

>以上这些模块依赖很多其他的基础模块，包括要使用到网络 存储 2D/3D图像 音频视频解码器 和 图片解码器。
>所以渲染引擎中还会包括如何使用这些依赖模块的部分。
	
## 渲染过程
* 浏览器渲染页面的整个过程：浏览器会从上到下解析文档。
	1. 遇见 HTML 标记，调用HTML解析器解析为对应的 token （一个token就是一个标签文本的序列化）并构建 DOM 树（就是一块内存，保存着tokens，建立它们之间的关系）。
  2. 遇见 style/link 标记 调用css解析器 处理 CSS 标记并构建 CSSOM 树。
  3. 遇见 script 标记 调用 javascript解析器 处理script标记，绑定事件、修改DOM树/CSSOM树 等
  4. 将 DOM 与 CSSOM 合并成一个渲染树。
  5. 根据渲染树来布局，以计算每个节点的几何信息。
  6. 将各个节点绘制到屏幕上。
   
        >需要明白，这五个步骤并不一定按顺序执行完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。
        >实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM

	7. 阻塞渲染		
		* css阻塞
			* css 在head中引入会阻塞页面的渲染	
				为什么？
					避免闪屏现象												
			* css 阻塞js的执行，不阻塞js等其他资源的加载	
				为什么？											
					脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，
					脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，
					但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。
					而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。
		* js阻塞
			* 直接引入的js会阻塞页面的渲染
				为什么？
					Javascript代码可能会修改DOM树的结构
			* js顺序执行，阻塞后续js逻辑的执行，不阻塞js等其他资源的加载
				为什么？
					维护依赖关系
						
			* 预解析
					WebKit 和 Firefox 都进行了这项优化。在执行js脚本时，其他线程会解析文档的其余部分，
					找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，
					从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；
					预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。
					
		>在上述的过程中，网页在加载和渲染过程中会发出“DOMContentloaded”和“onload”事件
		>分别在DOM树构建完成之后，以及DOM树构建完并且网页所依赖的资源都加载完之后发生、
		>因为某些资源的加载并不会阻碍DOM树的创建，所以这两个事假多数是不同时发生的
	
* 从DOM树到可视化图像
	1) CSS文件被CSS解析器解释成内部表示结构(CSSDOM)
	2) CSS解析器工作完成之后，在DOM树上附加解释后的样式信息，这就是RenderObject树
	3) RenderObject在创建的同时，Webkit会根据网页的结构创建RenderLayer，同时构建一个绘图上下文
	4) 根据绘图上下文生成最终的图像（这一过程需要依赖图形库）
		 

* 上面介绍的是一个完整的渲染过程，但现代网页很多都是动态的，这意味着在渲染完成之后，由于网页的动画或者用户的交互，
	浏览器其实一直在不停地重复执行渲染过程。（重绘重排），以上的数字表示的是基本顺序，这不是严格一致的，
	这个过程可能重复也可能交叉

	
	
	

			
	  
